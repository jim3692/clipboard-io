/**
 * Minified by jsDelivr using Terser v5.37.0.
 * Original file: /npm/opencrypto@1.5.5/src/OpenCrypto.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const cryptoLib=window.crypto||window.msCrypto,cryptoApi=cryptoLib.subtle||cryptoLib.webkitSubtle,chars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",lookup=new Uint8Array(256),PBES2_OID="06092a864886f70d01050d",PBKDF2_OID="06092a864886f70d01050c",AES256GCM_OID="060960864801650304012e",AES192GCM_OID="060960864801650304011a",AES128GCM_OID="0609608648016503040106",AES256CBC_OID="060960864801650304012a",AES192CBC_OID="0609608648016503040116",AES128CBC_OID="0609608648016503040102",AES256CFB_OID="060960864801650304012c",AES192CFB_OID="0609608648016503040118",AES128CFB_OID="06086086480165030404",SHA512_OID="06082a864886f70d020b0500",SHA384_OID="06082a864886f70d020a0500",SHA256_OID="06082a864886f70d02090500",SHA1_OID="06082a864886f70d02070500",RSA_OID="06092a864886f70d010101",EC_OID="06072a8648ce3d0201",P256_OID="06082a8648ce3d030107",P384_OID="06052b81040022",P521_OID="06052b81040023";export default class OpenCrypto{constructor(){for(let e=0;e<64;e++)lookup[chars.charCodeAt(e)]=e}encodeAb(e){const t=new Uint8Array(e),r=t.length;let o="";for(let e=0;e<r;e+=3)o+=chars[t[e]>>2],o+=chars[(3&t[e])<<4|t[e+1]>>4],o+=chars[(15&t[e+1])<<2|t[e+2]>>6],o+=chars[63&t[e+2]];return r%3==2?o=o.substring(0,o.length-1)+"=":r%3==1&&(o=o.substring(0,o.length-2)+"=="),o}decodeAb(e){const t=e.length;let r,o,a,n,i=.75*e.length,p=0;"="===e[e.length-1]&&(i--,"="===e[e.length-2]&&i--);const s=new ArrayBuffer(i);let h=new Uint8Array(s);for(let i=0;i<t;i+=4)r=lookup[e.charCodeAt(i)],o=lookup[e.charCodeAt(i+1)],a=lookup[e.charCodeAt(i+2)],n=lookup[e.charCodeAt(i+3)],h[p++]=r<<2|o>>4,h[p++]=(15&o)<<4|a>>2,h[p++]=(3&a)<<6|63&n;return s}arrayBufferToString(e){if("object"!=typeof e)throw new TypeError("Expected input of arrayBuffer to be an ArrayBuffer Object");return new TextDecoder("utf-8").decode(e)}stringToArrayBuffer(e){if("string"!=typeof e)throw new TypeError("Expected input of str to be a String");return new TextEncoder("utf-8").encode(e).buffer}arrayBufferToHexString(e){if("object"!=typeof e)throw new TypeError("Expected input of arrayBuffer to be an ArrayBuffer Object");const t=new Uint8Array(e);let r,o="";for(let e=0;e<t.byteLength;e++)r=t[e].toString(16),r.length<2&&(r="0"+r),o+=r;return o}hexStringToArrayBuffer(e){if("string"!=typeof e)throw new TypeError("Expected input of hexString to be a String");if(e.length%2!=0)throw new RangeError("Expected string to be an even number of characters");const t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substring(r,r+2),16);return t.buffer}arrayBufferToBase64(e){if("object"!=typeof e)throw new TypeError("Expected input of arrayBuffer to be an ArrayBuffer Object");return this.encodeAb(e)}base64ToArrayBuffer(e){if("string"!=typeof e)throw new TypeError("Expected input of b64 to be a Base64 String");return this.decodeAb(e)}decimalToHex(e,t){if("boolean"!=typeof(t=void 0!==t&&t))throw new TypeError("Expected input of unsigned to be a Boolean");let r=null;if("number"==typeof e)return t?(r=e.toString(16),r.length%2?"000"+r:"00"+r):(r=e.toString(16),r.length%2?"0"+r:r);if("string"==typeof e)return r=(e.length/2).toString(16),r.length%2?"0"+r:r;throw new TypeError("Expected input of d to be a Number or String")}addNewLines(e){let t="";for(;e.length>0;)t+=e.substring(0,64)+"\r\n",e=e.substring(64);return t}removeLines(e){return e.replace(/\r?\n|\r/g,"")}toAsn1(e,t,r,o,a,n,i){e=this.arrayBufferToHexString(e),t=this.arrayBufferToHexString(t),r=this.arrayBufferToHexString(r),o=this.decimalToHex(o,!0);const p={};switch(a){case"SHA-512":p.HASH_OID=SHA512_OID;break;case"SHA-384":p.HASH_OID=SHA384_OID;break;case"SHA-256":p.HASH_OID=SHA256_OID;break;case"SHA-1":p.HASH_OID=SHA1_OID}switch(n){case"AES-GCM":256===i?p.CIPHER_OID=AES256GCM_OID:192===i?p.CIPHER_OID=AES192GCM_OID:128===i&&(p.CIPHER_OID=AES128GCM_OID);break;case"AES-CBC":256===i?p.CIPHER_OID=AES256CBC_OID:192===i?p.CIPHER_OID=AES192CBC_OID:128===i&&(p.CIPHER_OID=AES128CBC_OID);break;case"AES-CFB":256===i?p.CIPHER_OID=AES256CFB_OID:192===i?p.CIPHER_OID=AES192CFB_OID:128===i&&(p.CIPHER_OID=AES128CFB_OID)}const s="02"+this.decimalToHex(o.length/2)+o,h="04"+this.decimalToHex(t)+t,y="04"+this.decimalToHex(r)+r,c="04"+(this.decimalToHex(e).length/2==2?"82":"81")+this.decimalToHex(e)+e;p.SEQUENCE_AES_CONTAINER="30"+this.decimalToHex(p.CIPHER_OID+y),p.SEQUENCE_HASH_CONTAINER="30"+this.decimalToHex(p.HASH_OID),p.SEQUENCE_PBKDF2_INNER_CONTAINER="30"+this.decimalToHex(h+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID),p.SEQUENCE_PBKDF2_CONTAINER="30"+this.decimalToHex(PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+h+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID),p.SEQUENCE_PBES2_INNER_CONTAINER="30"+this.decimalToHex(p.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+h+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID+p.SEQUENCE_AES_CONTAINER+p.CIPHER_OID+y),p.SEQUENCE_PBES2_CONTAINER="30"+this.decimalToHex(PBES2_OID+p.SEQUENCE_PBES2_INNER_CONTAINER+p.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+h+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID+p.SEQUENCE_AES_CONTAINER+p.CIPHER_OID+y);const f=p.SEQUENCE_PBES2_CONTAINER+PBES2_OID+p.SEQUENCE_PBES2_INNER_CONTAINER+p.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+h+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID+p.SEQUENCE_AES_CONTAINER+p.CIPHER_OID+y,E=this.decimalToHex(f+c),u="30"+(E.length/2==2?"82":"81")+E+f+c,d=this.hexStringToArrayBuffer(u);let g=this.arrayBufferToBase64(d);return g=this.addNewLines(g),g="-----BEGIN ENCRYPTED PRIVATE KEY-----\r\n"+g+"-----END ENCRYPTED PRIVATE KEY-----",g}fromAsn1(e){e=(e=(e=this.removeLines(e)).replace("-----BEGIN ENCRYPTED PRIVATE KEY-----","")).replace("-----END ENCRYPTED PRIVATE KEY-----",""),e=this.base64ToArrayBuffer(e);const t={},r=this.arrayBufferToHexString(e);t.data=r,t.data.includes(PBES2_OID)&&t.data.includes(PBKDF2_OID)&&(t.valid=!0),t.saltBegin=t.data.indexOf(PBKDF2_OID)+28,t.data.includes(AES256GCM_OID)?(t.cipher="AES-GCM",t.length=256,t.ivBegin=t.data.indexOf(AES256GCM_OID)+24):t.data.includes(AES192GCM_OID)?(t.cipher="AES-GCM",t.length=192,t.ivBegin=t.data.indexOf(AES192GCM_OID)+24):t.data.includes(AES128GCM_OID)?(t.cipher="AES-GCM",t.length=128,t.ivBegin=t.data.indexOf(AES128GCM_OID)+24):t.data.includes(AES256CBC_OID)?(t.cipher="AES-CBC",t.length=256,t.ivBegin=t.data.indexOf(AES256CBC_OID)+24):t.data.includes(AES192CBC_OID)?(t.cipher="AES-CBC",t.length=192,t.ivBegin=t.data.indexOf(AES192CBC_OID)+24):t.data.includes(AES128CBC_OID)?(t.cipher="AES-CBC",t.length=128,t.ivBegin=t.data.indexOf(AES128CBC_OID)+24):t.data.includes(AES256CFB_OID)?(t.cipher="AES-CFB",t.length=256,t.ivBegin=t.data.indexOf(AES256CFB_OID)+24):t.data.includes(AES192CFB_OID)?(t.cipher="AES-CFB",t.length=192,t.ivBegin=t.data.indexOf(AES192CFB_OID)+24):t.data.includes(AES128CFB_OID)&&(t.cipher="AES-CFB",t.length=128,t.ivBegin=t.data.indexOf(AES128CFB_OID)+22),t.data.includes(SHA512_OID)?t.hash="SHA-512":t.data.includes(SHA384_OID)?t.hash="SHA-384":t.data.includes(SHA256_OID)?t.hash="SHA-256":t.data.includes(SHA1_OID)&&(t.hash="SHA-1"),t.saltLength=parseInt(t.data.substr(t.saltBegin,2),16),t.ivLength=parseInt(t.data.substr(t.ivBegin,2),16),t.salt=t.data.substr(t.saltBegin+2,2*t.saltLength),t.iv=t.data.substr(t.ivBegin+2,2*t.ivLength),t.iterBegin=t.saltBegin+4+2*t.saltLength,t.iterLength=parseInt(t.data.substr(t.iterBegin,2),16),t.iter=parseInt(t.data.substr(t.iterBegin+2,2*t.iterLength),16),t.sequencePadding="81"===t.data.substr(2,2)?8:10,t.parametersPadding="81"===t.data.substr(2,2)?12:16,t.sequenceLength=parseInt(t.data.substr(t.sequencePadding,2),16),t.encryptedDataBegin=t.parametersPadding+2*t.sequenceLength,t.encryptedDataPadding="81"===t.data.substr(t.encryptedDataBegin-2,2)?2:4,t.encryptedDataLength=parseInt(t.data.substr(t.encryptedDataBegin,6),16),t.encryptedData=t.data.substr(t.encryptedDataBegin+t.encryptedDataPadding,2*t.encryptedDataLength);return{salt:this.hexStringToArrayBuffer(t.salt),iv:this.hexStringToArrayBuffer(t.iv),cipher:t.cipher,length:t.length,hash:t.hash,iter:t.iter,encryptedData:this.hexStringToArrayBuffer(t.encryptedData)}}cryptoPrivateToPem(e){const t=this;return new Promise(((r,o)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input to be a CryptoKey Object");cryptoApi.exportKey("pkcs8",e).then((e=>{const o=t.arrayBufferToBase64(e);let a=t.addNewLines(o);a="-----BEGIN PRIVATE KEY-----\r\n"+a+"-----END PRIVATE KEY-----",r(a)})).catch((e=>{o(e)}))}))}pemPrivateToCrypto(e,t){const r=this;return void 0===t&&(t={}),t.isExtractable=void 0===t.isExtractable||t.isExtractable,new Promise(((o,a)=>{if("string"!=typeof e)throw new TypeError("Expected input of pem to be a String");if("boolean"!=typeof t.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");e=(e=e.replace("-----BEGIN PRIVATE KEY-----","")).replace("-----END PRIVATE KEY-----","");const n=r.removeLines(e),i=r.base64ToArrayBuffer(n),p=r.arrayBufferToHexString(i),s={};if(p.includes(EC_OID)){if(t.name=void 0!==t.name?t.name:"ECDH","string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");let e=null;if(p.includes(P256_OID)?e="P-256":p.includes(P384_OID)?e="P-384":p.includes(P521_OID)&&(e="P-521"),"ECDH"===t.name)t.usages=void 0!==t.usages?t.usages:["deriveKey","deriveBits"];else{if("ECDSA"!==t.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");t.usages=void 0!==t.usages?t.usages:["sign"]}if("object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");s.name=t.name,s.namedCurve=e}else{if(!p.includes(RSA_OID))throw new TypeError("Expected input of pem is not a valid private key");if(t.name=void 0!==t.name?t.name:"RSA-OAEP",t.hash=void 0!==t.hash?t.hash:"SHA-512","string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");if("string"!=typeof t.hash)throw new TypeError("Expected input of options.hash to be a String");if("RSA-OAEP"===t.name)t.usages=void 0!==t.usages?t.usages:["decrypt","unwrapKey"];else{if("RSA-PSS"!==t.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");t.usages=void 0!==t.usages?t.usages:["sign"]}if("object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");s.name=t.name,s.hash={},s.hash.name=t.hash}cryptoApi.importKey("pkcs8",i,s,t.isExtractable,t.usages).then((e=>{o(e)})).catch((e=>{a(e)}))}))}cryptoPublicToPem(e){const t=this;return new Promise(((r,o)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");cryptoApi.exportKey("spki",e).then((e=>{const o=t.arrayBufferToBase64(e);let a=t.addNewLines(o);a="-----BEGIN PUBLIC KEY-----\r\n"+a+"-----END PUBLIC KEY-----",r(a)})).catch((e=>{o(e)}))}))}pemPublicToCrypto(e,t){const r=this;return void 0===t&&(t={}),t.isExtractable=void 0===t.isExtractable||t.isExtractable,new Promise(((o,a)=>{if("string"!=typeof e)throw new TypeError("Expected input of pem to be a String");if("boolean"!=typeof t.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");e=(e=e.replace("-----BEGIN PUBLIC KEY-----","")).replace("-----END PUBLIC KEY-----","");const n=r.removeLines(e),i=r.base64ToArrayBuffer(n),p=r.arrayBufferToHexString(i),s={};if(p.includes(EC_OID)){if(t.name=void 0!==t.name?t.name:"ECDH","string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");let e=null;if(p.includes(P256_OID)?e="P-256":p.includes(P384_OID)?e="P-384":p.includes(P521_OID)&&(e="P-521"),"ECDH"===t.name)t.usages=void 0!==t.usages?t.usages:[];else{if("ECDSA"!==t.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");t.usages=void 0!==t.usages?t.usages:["verify"]}if("object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");s.name=t.name,s.namedCurve=e}else{if(!p.includes(RSA_OID))throw new TypeError("Expected input of pem is not a valid public key");if(t.name=void 0!==t.name?t.name:"RSA-OAEP",t.hash=void 0!==t.hash?t.hash:"SHA-512","string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");if("string"!=typeof t.hash)throw new TypeError("Expected input of options.hash to be a String");if("RSA-OAEP"===t.name)t.usages=void 0!==t.usages?t.usages:["encrypt","wrapKey"];else{if("RSA-PSS"!==t.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");t.usages=void 0!==t.usages?t.usages:["verify"]}if("object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");s.name=t.name,s.hash={},s.hash.name=t.hash}cryptoApi.importKey("spki",i,s,t.isExtractable,t.usages).then((e=>{o(e)})).catch((e=>{a(e)}))}))}cryptoToBase64(e,t){const r=this;let o=null;switch(e.type){case"secret":o="raw";break;case"private":o="pkcs8";break;case"public":o="spki"}return t=void 0!==t?t:o,new Promise(((a,n)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e))throw new TypeError("Expected input of key to be a CryptoKey Object");if("string"!=typeof t)throw new TypeError("Expected input of type to be a String");cryptoApi.exportKey(o,e).then((e=>{const t=r.arrayBufferToBase64(e);a(t)})).catch((e=>{n(e)}))}))}base64ToCrypto(e,t){const r=this;return void 0===t&&(t={}),t.name=void 0!==t.name?t.name:"AES-GCM",t.isExtractable=void 0===t.isExtractable||t.isExtractable,new Promise(((o,a)=>{if("string"!=typeof e)throw new TypeError("Expected input of key to be a Base64 String");if("string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");if("boolean"!=typeof t.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");const n={};if(n.name=t.name,"AES-GCM"===t.name||"AES-CBC"===t.name){if(t.type=void 0!==t.type?t.type:"raw",t.length=void 0!==t.length?t.length:256,t.usages=void 0!==t.usages?t.usages:["encrypt","decrypt","wrapKey","unwrapKey"],"number"!=typeof t.length)throw new TypeError("Expected input of options.length to be a Number")}else if("ECDH"===t.name){if(t.type=void 0!==t.type?t.type:"pkcs8",t.namedCurve=void 0!==t.namedCurve?t.namedCurve:"P-256",t.usages=void 0!==t.usages?t.usages:["deriveKey","deriveBits"],"string"!=typeof t.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");n.namedCurve=t.namedCurve}else if("ECDSA"===t.name){if(t.type=void 0!==t.type?t.type:"pkcs8",t.namedCurve=void 0!==t.namedCurve?t.namedCurve:"P-256",t.usages=void 0!==t.usages?t.usages:["sign"],"string"!=typeof t.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");n.namedCurve=t.namedCurve}else if("RSA-OAEP"===t.name){if(t.type=void 0!==t.type?t.type:"pkcs8",t.hash=void 0!==t.hash?t.hash:"SHA-512",t.usages=void 0!==t.usages?t.usages:["decrypt","unwrapKey"],"string"!=typeof t.hash)throw new TypeError("Expected input of options.hash to be a String");n.hash={},n.hash.name=t.hash}else{if("RSA-PSS"!==t.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");if(t.type=void 0!==t.type?t.type:"pkcs8",t.hash=void 0!==t.hash?t.hash:"SHA-512",t.usages=void 0!==t.usages?t.usages:["sign"],"string"!=typeof t.hash)throw new TypeError("Expected input of options.hash to be a String");n.hash={},n.hash.name=t.hash}if("string"!=typeof t.type)throw new TypeError("Expected input of options.type to be a String");if("object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");const i=r.base64ToArrayBuffer(e);cryptoApi.importKey(t.type,i,n,t.isExtractable,t.usages).then((e=>{o(e)})).catch((e=>{a(e)}))}))}getRSAKeyPair(e,t,r,o,a){return e=void 0!==e?e:2048,t=void 0!==t?t:"SHA-512",r=void 0!==r?r:"RSA-OAEP",a=void 0===a||a,new Promise(((n,i)=>{if("number"!=typeof e)throw new TypeError("Expected input of modulusLength to be a Number");if("string"!=typeof t)throw new TypeError("Expected input of hash expected to be a String");if("string"!=typeof r)throw new TypeError("Expected input of paddingScheme to be a String");if("boolean"!=typeof a)throw new TypeError("Expected input of isExtractable to be a Boolean");if("RSA-OAEP"===r)o=void 0!==o?o:["encrypt","decrypt","wrapKey","unwrapKey"];else{if("RSA-PSS"!==r)throw new TypeError("Expected input of paddingScheme is not a valid padding scheme");o=void 0!==o?o:["sign","verify"]}if("object"!=typeof o)throw new TypeError("Expected input of usages to be an Array");cryptoApi.generateKey({name:r,modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:t}},a,o).then((e=>{n(e)})).catch((e=>{i(e)}))}))}rsaEncrypt(e,t){const r=this;return new Promise(((o,a)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");if("object"!=typeof t)throw new TypeError("Expected input of data to be an ArrayBuffer");cryptoApi.encrypt({name:"RSA-OAEP"},e,t).then((e=>{const t=r.arrayBufferToBase64(e);o(t)})).catch((e=>{a(e)}))}))}rsaDecrypt(e,t){const r=this;return new Promise(((o,a)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("string"!=typeof t)throw new TypeError("Expected input of encryptedData to be a Base64 String");const n=r.base64ToArrayBuffer(t);cryptoApi.decrypt({name:"RSA-OAEP"},e,n).then((e=>{o(e)})).catch((e=>{a(e)}))}))}getECKeyPair(e,t,r,o){return e=void 0!==e?e:"P-256",t=void 0!==t?t:"ECDH",o=void 0===o||o,new Promise(((a,n)=>{if("string"!=typeof e)throw new TypeError("Expected input of curve to be a String");if("string"!=typeof t)throw new TypeError("Expected input of type to be a String");if("boolean"!=typeof o)throw new TypeError("Expected input of isExtractable to be a Boolean");if("ECDH"===t)r=void 0!==r?r:["deriveKey","deriveBits"];else{if("ECDSA"!==t)throw new TypeError("Expected input of type is not a valid algorithm type");r=void 0!==r?r:["sign","verify"]}if("object"!=typeof r)throw new TypeError("Expected input of usages to be an Array");cryptoApi.generateKey({name:t,namedCurve:e},o,r).then((e=>{a(e)})).catch((e=>{n(e)}))}))}getPublicKey(e,t){return void 0===t&&(t={}),t.isExtractable=void 0===t.isExtractable||t.isExtractable,new Promise(((r,o)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey must be a CryptoKey Object of type private");if("boolean"!=typeof t.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");cryptoApi.exportKey("jwk",e).then((a=>{const n={};switch(n.name=e.algorithm.name,e.algorithm.name){case"ECDH":if(delete a.d,a.key_ops=[],t.usages=void 0!==t.usages?t.usages:[],"object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");n.namedCurve=e.algorithm.namedCurve;break;case"ECDSA":if(delete a.d,a.key_ops=["verify"],t.usages=void 0!==t.usages?t.usages:["verify"],"object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");n.namedCurve=e.algorithm.namedCurve;break;case"RSA-OAEP":if(delete a.d,delete a.dp,delete a.dq,delete a.p,delete a.q,delete a.qi,a.key_ops=["encrypt","wrapKey"],t.usages=void 0!==t.usages?t.usages:["encrypt","wrapKey"],"object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");n.hash={},n.hash.name=e.algorithm.hash.name;break;case"RSA-PSS":if(delete a.d,delete a.dp,delete a.dq,delete a.p,delete a.q,delete a.qi,a.key_ops=["verify"],t.usages=void 0!==t.usages?t.usages:["verify"],"object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");n.hash={},n.hash.name=e.algorithm.hash.name;break;default:throw new TypeError("Expected input of privateKey is not a valid private key")}cryptoApi.importKey("jwk",a,n,t.isExtractable,t.usages).then((e=>{r(e)})).catch((e=>{o(e)}))})).catch((e=>{o(e)}))}))}encryptPrivateKey(e,t,r,o,a,n){const i=this;return r=void 0!==r?r:64e3,o=void 0!==o?o:"SHA-512",a=void 0!==a?a:"AES-GCM",n=void 0!==n?n:256,new Promise(((p,s)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("string"!=typeof t)throw new TypeError("Expected input of passphrase to be a String");if("number"!=typeof r)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof o)throw new TypeError("Expected input of hash to be a String");if("string"!=typeof a)throw new TypeError("Expected input of cipher to be a String");if("number"!=typeof n)throw new TypeError("Expected input of length to be a Number");let h=null;switch(a){case"AES-GCM":h=12;break;case"AES-CBC":case"AES-CFB":h=16}const y=cryptoLib.getRandomValues(new Uint8Array(16)),c=cryptoLib.getRandomValues(new Uint8Array(h)),f=i.stringToArrayBuffer(t);cryptoApi.importKey("raw",f,{name:"PBKDF2"},!1,["deriveKey"]).then((t=>{cryptoApi.deriveKey({name:"PBKDF2",salt:y,iterations:r,hash:o},t,{name:a,length:n},!1,["wrapKey"]).then((t=>{cryptoApi.wrapKey("pkcs8",e,t,{name:a,iv:c,tagLength:128}).then((e=>{const t=i.toAsn1(e,y,c,r,o,a,n);p(t)})).catch((e=>{s(e)}))})).catch((e=>{s(e)}))})).catch((e=>{s(e)}))}))}decryptPrivateKey(e,t,r){const o=this;return void 0===r&&(r={}),r.name=void 0!==r.name?r.name:"ECDH",r.isExtractable=void 0===r.isExtractable||r.isExtractable,new Promise(((a,n)=>{if("string"!=typeof e)throw new TypeError("Expected input of encryptedPrivateKey to be a Base64 String");if("string"!=typeof t)throw new TypeError("Expected input of passphrase to be a String");if("boolean"!=typeof r.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");const i=this.fromAsn1(e),p={};if(p.name=r.name,"ECDH"===r.name){if(r.namedCurve=void 0!==r.namedCurve?r.namedCurve:"P-256",r.usages=void 0!==r.usages?r.usages:["deriveKey","deriveBits"],"string"!=typeof r.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");if("object"!=typeof r.usages)throw new TypeError("Expected input of options.usages to be an Array");p.namedCurve=r.namedCurve}else if("ECDSA"===r.name){if(r.namedCurve=void 0!==r.namedCurve?r.namedCurve:"P-256",r.usages=void 0!==r.usages?r.usages:["sign"],"string"!=typeof r.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");if("object"!=typeof r.usages)throw new TypeError("Expected input of options.usages to be an Array");p.namedCurve=r.namedCurve}else if("RSA-OAEP"===r.name){if(r.hash=void 0!==r.hash?r.hash:"SHA-512",r.usages=void 0!==r.usages?r.usages:["decrypt","unwrapKey"],"string"!=typeof r.hash)throw new TypeError("Expected input of options.hash to be a String");if("object"!=typeof r.usages)throw new TypeError("Expected input of options.usages to be an Array");p.hash={},p.hash.name=r.hash}else{if("RSA-PSS"!==r.name)throw new TypeError("Expected input of encryptedPrivateKey is not a valid encrypted private key");if(r.hash=void 0!==r.hash?r.hash:"SHA-512",r.usages=void 0!==r.usages?r.usages:["sign"],"string"!=typeof r.hash)throw new TypeError("Expected input of options.hash to be a String");if("object"!=typeof r.usages)throw new TypeError("Expected input of options.usages to be an Array");p.hash={},p.hash.name=r.hash}const s=o.stringToArrayBuffer(t);cryptoApi.importKey("raw",s,{name:"PBKDF2"},!1,["deriveKey"]).then((e=>{cryptoApi.deriveKey({name:"PBKDF2",salt:i.salt,iterations:i.iter,hash:i.hash},e,{name:i.cipher,length:i.length},!1,["unwrapKey"]).then((e=>{cryptoApi.unwrapKey("pkcs8",i.encryptedData,e,{name:i.cipher,iv:i.iv,tagLength:128},p,r.isExtractable,r.usages).then((e=>{a(e)})).catch((e=>{n(e)}))})).catch((e=>{n(e)}))})).catch((e=>{n(e)}))}))}keyAgreement(e,t,r){return void 0===r&&(r={}),r.bitLength=void 0!==r.bitLength?r.bitLength:256,r.hkdfHash=void 0!==r.hkdfHash?r.hkdfHash:"SHA-512",r.hkdfSalt=void 0!==r.hkdfSalt?r.hkdfSalt:new Uint8Array,r.hkdfInfo=void 0!==r.hkdfInfo?r.hkdfInfo:new Uint8Array,r.cipher=void 0!==r.cipher?r.cipher:"AES-GCM",r.length=void 0!==r.length?r.length:256,r.usages=void 0!==r.usages?r.usages:["encrypt","decrypt","unwrapKey","wrapKey"],r.isExtractable=void 0===r.isExtractable||r.isExtractable,new Promise(((o,a)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("[object CryptoKey]"!==Object.prototype.toString.call(t)&&"public"!==t.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");if("number"!=typeof r.bitLength)throw new TypeError("Expected input of options.bitLength to be a Number");if("string"!=typeof r.hkdfHash)throw new TypeError("Expected input of options.hkdfHash to be a String");if("object"!=typeof r.hkdfSalt)throw new TypeError("Expected input of options.hkdfSalt to be an ArrayBuffer");if("object"!=typeof r.hkdfInfo)throw new TypeError("Expected input of options.hkdfInfo to be an ArrayBuffer");if("string"!=typeof r.cipher)throw new TypeError("Expected input of options.cipher to be a String");if("number"!=typeof r.length)throw new TypeError("Expected input of options.length to be a Number");if("object"!=typeof r.usages)throw new TypeError("Expected input of options.usages to be an Array");if("boolean"!=typeof r.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");cryptoApi.deriveBits({name:"ECDH",namedCurve:t.algorithm.namedCurve,public:t},e,r.bitLength).then((e=>{cryptoApi.importKey("raw",e,{name:"HKDF"},!1,["deriveKey"]).then((e=>{cryptoApi.deriveKey({name:"HKDF",hash:{name:r.hkdfHash},salt:r.hkdfSalt,info:r.hkdfInfo},e,{name:r.cipher,length:r.length},r.isExtractable,r.usages).then((e=>{o(e)})).catch((e=>{a(e)}))})).catch((e=>{a(e)}))})).catch((e=>{a(e)}))}))}getSharedKey(e,t){return e=void 0!==e?e:256,void 0===t&&(t={}),t.cipher=void 0!==t.cipher?t.cipher:"AES-GCM",t.usages=void 0!==t.usages?t.usages:["encrypt","decrypt","wrapKey","unwrapKey"],t.isExtractable=void 0===t.isExtractable||t.isExtractable,new Promise(((r,o)=>{if("number"!=typeof e)throw new TypeError("Expected input of length to be a Number");if("string"!=typeof t.cipher)throw new TypeError("Expected input of options.cipher expected to be a String");if("object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");if("boolean"!=typeof t.isExtractable)throw new TypeError("Expected input of options.isExtractable expected to be a Boolean");cryptoApi.generateKey({name:t.cipher,length:e},t.isExtractable,t.usages).then((e=>{r(e)})).catch((e=>{o(e)}))}))}encryptKey(e,t){const r=this;return new Promise(((o,a)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e))throw new TypeError("Expected input of wrappingKey to be a CryptoKey Object");if("[object CryptoKey]"!==Object.prototype.toString.call(t))throw new TypeError("Expected input of key to be a CryptoKey Object");let n=null;switch(t.type){case"secret":n="raw";break;case"private":n="pkcs8";break;case"public":n="spki"}if("secret"===e.type){let i=null;if("AES-GCM"===e.algorithm.name)i=cryptoLib.getRandomValues(new Uint8Array(12));else{if("AES-CBC"!==e.algorithm.name)throw new TypeError("Cipher mode of the wrappingKey is not supported");i=cryptoLib.getRandomValues(new Uint8Array(16))}cryptoApi.wrapKey(n,t,e,{name:e.algorithm.name,iv:i,tagLength:128}).then((e=>{const t=r.arrayBufferToBase64(i)+r.arrayBufferToBase64(e);o(t)})).catch((e=>{a(e)}))}else{if("RSA-OAEP"!==e.algorithm.name)throw new TypeError("Expected input of wrappingKey is not a supported key");if("public"!==e.type)throw new TypeError("Expected input of wrappingKey to be a CryptoKey Object of type public");cryptoApi.wrapKey(n,t,e,{name:"RSA-OAEP",hash:{name:e.algorithm.hash.name}}).then((e=>{const t=r.arrayBufferToBase64(e);o(t)})).catch((e=>{a(e)}))}}))}decryptKey(e,t,r){const o=this;return void 0===r&&(r={}),r.name=void 0!==r.name?r.name:"AES-GCM",r.isExtractable=void 0===r.isExtractable||r.isExtractable,new Promise(((a,n)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e))throw new TypeError("Expected input of unwrappingKey to be a CryptoKey Object");if("string"!=typeof t)throw new TypeError("Expected input of encryptedKey to be a Base64 String");if("string"!=typeof r.name)throw new TypeError("Expected input of options.name to be a String");if("boolean"!=typeof r.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");const i={};if(i.name=r.name,"AES-GCM"===r.name||"AES-CBC"===r.name){if(r.type=void 0!==r.type?r.type:"raw",r.length=void 0!==r.length?r.length:256,r.usages=void 0!==r.usages?r.usages:["encrypt","decrypt","wrapKey","unwrapKey"],"number"!=typeof r.length)throw new TypeError("Expected input of options.length to be a Number")}else if("ECDH"===r.name){if(r.type=void 0!==r.type?r.type:"pkcs8",r.namedCurve=void 0!==r.namedCurve?r.namedCurve:"P-256",r.usages=void 0!==r.usages?r.usages:["deriveKey","deriveBits"],"string"!=typeof r.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");i.namedCurve=r.namedCurve}else if("ECDSA"===r.name){if(r.type=void 0!==r.type?r.type:"pkcs8",r.namedCurve=void 0!==r.namedCurve?r.namedCurve:"P-256",r.usages=void 0!==r.usages?r.usages:["sign"],"string"!=typeof r.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");i.namedCurve=r.namedCurve}else if("RSA-OAEP"===r.name){if(r.type=void 0!==r.type?r.type:"pkcs8",r.hash=void 0!==r.hash?r.hash:"SHA-512",r.usages=void 0!==r.usages?r.usages:["decrypt","unwrapKey"],"string"!=typeof r.hash)throw new TypeError("Expected input of options.hash to be a String");i.hash={},i.hash.name=r.hash}else{if("RSA-PSS"!==r.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");if(r.type=void 0!==r.type?r.type:"pkcs8",r.hash=void 0!==r.hash?r.hash:"SHA-512",r.usages=void 0!==r.usages?r.usages:["sign"],"string"!=typeof r.hash)throw new TypeError("Expected input of options.hash to be a String");i.hash={},i.hash.name=r.hash}if("string"!=typeof r.type)throw new TypeError("Expected input of options.type to be a String");if("object"!=typeof r.usages)throw new TypeError("Expected input of options.usages to be an Array");if("secret"===e.type){let p=null,s=null;if("AES-GCM"===e.algorithm.name)p=t.substring(0,16),s=t.substring(16);else{if("AES-CBC"!==e.algorithm.name)throw new TypeError("Cipher mode of the wrappingKey is not supported");p=t.substring(0,24),s=t.substring(24)}const h=o.base64ToArrayBuffer(p),y=o.base64ToArrayBuffer(s);cryptoApi.unwrapKey(r.type,y,e,{name:e.algorithm.name,iv:h,tagLength:128},i,r.isExtractable,r.usages).then((e=>{a(e)})).catch((e=>{n(e)}))}else{if("RSA-OAEP"!==e.algorithm.name)throw new TypeError("Expected input of unwrappingKey is not a supported key");{if("private"!==e.type)throw new TypeError("Expected input of unwrappingKey to be a CryptoKey Object of type private");const p=o.base64ToArrayBuffer(t);cryptoApi.unwrapKey(r.type,p,e,{name:"RSA-OAEP",modulusLength:e.algorithm.modulusLength,publicExponent:new Uint8Array([1,0,1]),hash:{name:e.algorithm.hash.name}},i,r.isExtractable,r.usages).then((e=>{a(e)})).catch((e=>{n(e)}))}}}))}signKey(e,t,r){const o=this;return void 0===r&&(r={}),new Promise(((a,n)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("[object CryptoKey]"!==Object.prototype.toString.call(t))throw new TypeError("Expected input of key to be a CryptoKey Object");cryptoApi.exportKey("raw",t).then((t=>{if("ECDSA"===e.algorithm.name){if(r.hash=void 0!==r.hash?r.hash:"SHA-512","string"!=typeof r.hash)throw new TypeError("Expected input of options.hash to be a String");cryptoApi.sign({name:"ECDSA",hash:{name:r.hash}},e,t).then((e=>{const t=o.arrayBufferToBase64(e);a(t)})).catch((e=>{n(e)}))}else{if("RSA-PSS"!==e.algorithm.name)throw new TypeError("Expected input of privateKey is not a valid private key");if(r.saltLength=void 0!==r.saltLength?r.saltLength:128,"number"!=typeof r.saltLength)throw new TypeError("Expected input of options.saltLength to be a Number");cryptoApi.sign({name:"RSA-PSS",saltLength:r.saltLength},e,t).then((e=>{const t=o.arrayBufferToBase64(e);a(t)})).catch((e=>{n(e)}))}})).catch((e=>{n(e)}))}))}verifyKey(e,t,r,o){const a=this;return void 0===o&&(o={}),new Promise(((n,i)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");if("[object CryptoKey]"!==Object.prototype.toString.call(t))throw new TypeError("Expected input of key to be a CryptoKey Object");if("string"!=typeof r)throw new TypeError("Expected input of signature to be a Base64 String");const p=a.base64ToArrayBuffer(r);cryptoApi.exportKey("raw",t).then((t=>{if("ECDSA"===e.algorithm.name){if(o.hash=void 0!==o.hash?o.hash:"SHA-512","string"!=typeof o.hash)throw new TypeError("Expected input of options.hash to be a String");cryptoApi.verify({name:"ECDSA",hash:{name:o.hash}},e,p,t).then((e=>{n(e)})).catch((e=>{i(e)}))}else{if("RSA-PSS"!==e.algorithm.name)throw new TypeError("Expected input of publicKey is not a valid public key");cryptoApi.verify({name:"RSA-PSS",saltLength:128},e,p,t).then((e=>{n(e)})).catch((e=>{i(e)}))}})).catch((e=>{i(e)}))}))}sign(e,t,r){const o=this;return void 0===r&&(r={}),new Promise(((a,n)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("object"!=typeof t)throw new TypeError("Expected input of data to be an ArrayBuffer");if("ECDSA"===e.algorithm.name){if(r.hash=void 0!==r.hash?r.hash:"SHA-512","string"!=typeof r.hash)throw new TypeError("Expected input of options.hash to be a String");cryptoApi.sign({name:"ECDSA",hash:{name:r.hash}},e,t).then((e=>{const t=o.arrayBufferToBase64(e);a(t)})).catch((e=>{n(e)}))}else{if("RSA-PSS"!==e.algorithm.name)throw new TypeError("Expected input of privateKey is not a valid private key");if(r.saltLength=void 0!==r.saltLength?r.saltLength:128,"number"!=typeof r.saltLength)throw new TypeError("Expected input of options.saltLength to be a Number");cryptoApi.sign({name:"RSA-PSS",saltLength:r.saltLength},e,t).then((e=>{const t=o.arrayBufferToBase64(e);a(t)})).catch((e=>{n(e)}))}}))}verify(e,t,r,o){const a=this;return void 0===o&&(o={}),new Promise(((n,i)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");if("object"!=typeof t)throw new TypeError("Expected input of data to be an ArrayBuffer");if("string"!=typeof r)throw new TypeError("Expected input of signature to be a Base64 String");const p=a.base64ToArrayBuffer(r);if("ECDSA"===e.algorithm.name){if(o.hash=void 0!==o.hash?o.hash:"SHA-512","string"!=typeof o.hash)throw new TypeError("Expected input of options.hash to be a String");cryptoApi.verify({name:"ECDSA",hash:{name:o.hash}},e,p,t).then((e=>{n(e)})).catch((e=>{i(e)}))}else{if("RSA-PSS"!==e.algorithm.name)throw new TypeError("Expected input of publicKey is not a valid public key");cryptoApi.verify({name:"RSA-PSS",saltLength:128},e,p,t).then((e=>{n(e)})).catch((e=>{i(e)}))}}))}encrypt(e,t){const r=this;return new Promise(((o,a)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"secret"!==e.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey Object");if("object"!=typeof t)throw new TypeError("Expected input of data to be an ArrayBuffer");let n=null;if("AES-GCM"===e.algorithm.name)n=cryptoLib.getRandomValues(new Uint8Array(12));else{if("AES-CBC"!==e.algorithm.name)throw new TypeError("Cipher mode of the sharedKey is not supported");n=cryptoLib.getRandomValues(new Uint8Array(16))}cryptoApi.encrypt({name:e.algorithm.name,iv:n,tagLength:128},e,t).then((e=>{const t=r.arrayBufferToBase64(n),a=r.arrayBufferToBase64(e);o(t+a)})).catch((e=>{a(e)}))}))}decrypt(e,t,r){const o=this;return void 0===r&&(r={}),r.cipher=void 0!==r.cipher?r.cipher:"AES-GCM",new Promise(((a,n)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"secret"!==e.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey Object");if("string"!=typeof t)throw new TypeError("Expected input of encryptedData to be a String");if("string"!=typeof r.cipher)throw new TypeError("Expected input of options.cipher to be a String");let i=null,p=null;if("AES-GCM"===r.cipher)i=t.substring(0,16),p=t.substring(16);else{if("AES-CBC"!==r.cipher)throw new TypeError("Cipher mode of the sharedKey is not supported");i=t.substring(0,24),p=t.substring(24)}const s=o.base64ToArrayBuffer(i),h=o.base64ToArrayBuffer(p);cryptoApi.decrypt({name:r.cipher,iv:s,tagLength:128},e,h).then((e=>{a(e)})).catch((e=>{n(e)}))}))}derivePassphraseKey(e,t,r,o){const a=this;return r=void 0!==r?r:64e3,void 0===o&&(o={}),o.hash=void 0!==o.hash?o.hash:"SHA-512",o.length=void 0!==o.length?o.length:256,o.cipher=void 0!==o.cipher?o.cipher:"AES-GCM",o.usages=void 0!==o.usages?o.usages:["encrypt","decrypt","wrapKey","unwrapKey"],o.isExtractable=void 0===o.isExtractable||o.isExtractable,new Promise(((n,i)=>{if("string"!=typeof e)throw new TypeError("Expected input of passphrase to be a String");if("object"!=typeof t)throw new TypeError("Expected input of salt to be an ArrayBuffer");if("number"!=typeof r)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof o.hash)throw new TypeError("Expected input of options.hash to be a String");if("number"!=typeof o.length)throw new TypeError("Expected input of options.length to be a Number");if("string"!=typeof o.cipher)throw new TypeError("Expected input of options.cipher to be a String");if("object"!=typeof o.usages)throw new TypeError("Expected input of options.usages to be an Array");if("boolean"!=typeof o.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");const p=a.stringToArrayBuffer(e);cryptoApi.importKey("raw",p,{name:"PBKDF2"},!1,["deriveKey"]).then((e=>{cryptoApi.deriveKey({name:"PBKDF2",salt:t,iterations:r,hash:{name:o.hash}},e,{name:o.cipher,length:o.length},o.isExtractable,o.usages).then((e=>{n(e)})).catch((e=>{i(e)}))})).catch((e=>{i(e)}))}))}hashPassphrase(e,t,r,o){const a=this;return r=void 0!==r?r:64e3,void 0===o&&(o={}),o.hash=void 0!==o.hash?o.hash:"SHA-512",o.length=void 0!==o.length?o.length:256,o.cipher=void 0!==o.cipher?o.cipher:"AES-GCM",o.usages=void 0!==o.usages?o.usages:["encrypt","decrypt","wrapKey","unwrapKey"],o.isExtractable=void 0===o.isExtractable||o.isExtractable,new Promise(((n,i)=>{if("string"!=typeof e)throw new TypeError("Expected input of passphrase to be a String");if("object"!=typeof t)throw new TypeError("Expected input of salt to be an ArrayBuffer");if("number"!=typeof r)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof o.hash)throw new TypeError("Expected input of options.hash to be a String");if("number"!=typeof o.length)throw new TypeError("Expected input of options.length to be a Number");if("string"!=typeof o.cipher)throw new TypeError("Expected input of options.cipher to be a String");if("object"!=typeof o.usages)throw new TypeError("Expected input of options.usages to be an Array");if("boolean"!=typeof o.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");a.derivePassphraseKey(e,t,r,o).then((e=>{cryptoApi.exportKey("raw",e).then((e=>{const t=a.arrayBufferToHexString(e);n(t)})).catch((e=>{i(e)}))})).catch((e=>{i(e)}))}))}getFingerprint(e,t){const r=this;return void 0===t&&(t={}),t.hash="undefined"!=typeof hash?hash:"SHA-512",t.isBuffer=void 0!==t.isBuffer&&t.isBuffer,new Promise(((o,a)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e))throw new TypeError("Expected input of key to be a CryptoKey Object");if("string"!=typeof t.hash)throw new TypeError("Expected input of options.hash to be a String");if("boolean"!=typeof t.isBuffer)throw new TypeError("Expected input of options.isBuffer to be a Boolean");let n=null;switch(e.type){case"secret":n="raw";break;case"private":n="pkcs8";break;case"public":n="spki"}cryptoApi.exportKey(n,e).then((e=>{cryptoApi.digest({name:t.hash},e).then((e=>{if(t.isBuffer)o(e);else{const t=r.arrayBufferToHexString(e);o(t)}})).catch((e=>{a(e)}))})).catch((e=>{a(e)}))}))}getRandomBytes(e){return e=void 0!==e?e:16,new Promise(((t,r)=>{if("number"!=typeof e)throw new TypeError("Expected input of size to be a Number");t(cryptoLib.getRandomValues(new Uint8Array(e)))}))}}
//# sourceMappingURL=/sm/446ea86639abe7c5d0c0f02f3cf09c164d0dcf39268316aeb4243d6b319d8b01.map